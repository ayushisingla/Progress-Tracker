{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.deg = deg;\nexports.transform = transform;\nexports.isWithinRadius = isWithinRadius;\nexports.calcAnimationAngle = calcAnimationAngle;\n\nvar _constants = require(\"./constants\");\n\nconst cos = Math.cos,\n      sin = Math.sin;\nconst pi = Math.PI;\nconst ANGLE_PER_INCREMENT = 360 / _constants.VISIBLE_NUMBERS_PER_CIRCLE;\n\nfunction rad(deg) {\n  return deg / (180 / pi);\n}\n\nfunction deg(rad) {\n  return rad * (180 / pi);\n} // translate number position\n\n\nfunction translateX(index, transform) {\n  return sin(rad(index * -ANGLE_PER_INCREMENT - 180)) * (_constants.CLOCK_RADIUS - transform) + _constants.CLOCK_RADIUS - _constants.NUMBER_RADIUS_REGULAR / 2;\n}\n\nfunction translateY(index, transform) {\n  return cos(rad(index * -ANGLE_PER_INCREMENT - 180)) * (_constants.CLOCK_RADIUS - transform) + _constants.CLOCK_RADIUS - _constants.NUMBER_RADIUS_REGULAR / 2;\n} // calculate number position for animation\n\n\nfunction transform(index, t) {\n  const x = translateX(index, t);\n  const y = translateY(index, t);\n  return \"translate(\".concat(x, \"px, \").concat(y, \"px)\");\n}\n\nfunction isWithinRadius(x, y, radius) {\n  return Math.sqrt(x * x + y * y) < radius;\n} // normalize any angles to 0-360 deg\n\n\nfunction normalize(angle) {\n  return (angle % 360 + 360) % 360;\n}\n/*\n\tcalculates the shortest angle between the prev and next angle\n\tto animate to - positive spins clockwise, negative is ccw\n\n\t- prev is the previous angle - can literally be almost any value,\n\teg: 480 is valid, -480 is valid\n\t- next is the angle to rotate to - is always between 0-360\n\t- must return an angle relative to the previous, so once again\n\tthis value can be any negative or positive value (like prev)\n\n\tfunction normalizes each angle, creates an upper and lower bound\n\tbased on previous angle and figures out which direction is shorter\n\tfor next - then diff and add/subtract to previous angle\n*/\n\n\nfunction calcAnimationAngle(prev, next) {\n  const p = normalize(prev);\n  const n = normalize(next);\n  let lower = p;\n  let upper = p; // TODO - implement without while loops\n\n  while (n < lower) {\n    lower -= 360;\n  }\n\n  while (n >= upper) {\n    upper += 360;\n  }\n\n  if (upper - n < n - lower) {\n    return prev - (upper - n);\n  } else {\n    return prev + (n - lower);\n  }\n}","map":{"version":3,"sources":["/home/ayushi/Documents/Workspace/Final/Safeearth/node_modules/react-timekeeper/lib/helpers/math.js"],"names":["Object","defineProperty","exports","value","deg","transform","isWithinRadius","calcAnimationAngle","_constants","require","cos","Math","sin","pi","PI","ANGLE_PER_INCREMENT","VISIBLE_NUMBERS_PER_CIRCLE","rad","translateX","index","CLOCK_RADIUS","NUMBER_RADIUS_REGULAR","translateY","t","x","y","concat","radius","sqrt","normalize","angle","prev","next","p","n","lower","upper"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.deg = deg;\nexports.transform = transform;\nexports.isWithinRadius = isWithinRadius;\nexports.calcAnimationAngle = calcAnimationAngle;\n\nvar _constants = require(\"./constants\");\n\nconst cos = Math.cos,\n      sin = Math.sin;\nconst pi = Math.PI;\nconst ANGLE_PER_INCREMENT = 360 / _constants.VISIBLE_NUMBERS_PER_CIRCLE;\n\nfunction rad(deg) {\n  return deg / (180 / pi);\n}\n\nfunction deg(rad) {\n  return rad * (180 / pi);\n} // translate number position\n\n\nfunction translateX(index, transform) {\n  return sin(rad(index * -ANGLE_PER_INCREMENT - 180)) * (_constants.CLOCK_RADIUS - transform) + _constants.CLOCK_RADIUS - _constants.NUMBER_RADIUS_REGULAR / 2;\n}\n\nfunction translateY(index, transform) {\n  return cos(rad(index * -ANGLE_PER_INCREMENT - 180)) * (_constants.CLOCK_RADIUS - transform) + _constants.CLOCK_RADIUS - _constants.NUMBER_RADIUS_REGULAR / 2;\n} // calculate number position for animation\n\n\nfunction transform(index, t) {\n  const x = translateX(index, t);\n  const y = translateY(index, t);\n  return \"translate(\".concat(x, \"px, \").concat(y, \"px)\");\n}\n\nfunction isWithinRadius(x, y, radius) {\n  return Math.sqrt(x * x + y * y) < radius;\n}\n\n// normalize any angles to 0-360 deg\nfunction normalize(angle) {\n  return (angle % 360 + 360) % 360;\n}\n/*\n\tcalculates the shortest angle between the prev and next angle\n\tto animate to - positive spins clockwise, negative is ccw\n\n\t- prev is the previous angle - can literally be almost any value,\n\teg: 480 is valid, -480 is valid\n\t- next is the angle to rotate to - is always between 0-360\n\t- must return an angle relative to the previous, so once again\n\tthis value can be any negative or positive value (like prev)\n\n\tfunction normalizes each angle, creates an upper and lower bound\n\tbased on previous angle and figures out which direction is shorter\n\tfor next - then diff and add/subtract to previous angle\n*/\n\n\nfunction calcAnimationAngle(prev, next) {\n  const p = normalize(prev);\n  const n = normalize(next);\n  let lower = p;\n  let upper = p; // TODO - implement without while loops\n\n  while (n < lower) {\n    lower -= 360;\n  }\n\n  while (n >= upper) {\n    upper += 360;\n  }\n\n  if (upper - n < n - lower) {\n    return prev - (upper - n);\n  } else {\n    return prev + (n - lower);\n  }\n}"]},"metadata":{},"sourceType":"script"}